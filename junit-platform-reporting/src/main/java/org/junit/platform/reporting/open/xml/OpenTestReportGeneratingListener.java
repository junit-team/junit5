/*
 * Copyright 2015-2025 the original author or authors.
 *
 * All rights reserved. This program and the accompanying materials are
 * made available under the terms of the Eclipse Public License v2.0 which
 * accompanies this distribution and is available at
 *
 * https://www.eclipse.org/legal/epl-v20.html
 */

package org.junit.platform.reporting.open.xml;

import static java.util.Objects.requireNonNull;
import static org.apiguardian.api.API.Status.EXPERIMENTAL;
import static org.junit.platform.commons.util.StringUtils.isNotBlank;
import static org.junit.platform.launcher.LauncherConstants.STDERR_REPORT_ENTRY_KEY;
import static org.junit.platform.launcher.LauncherConstants.STDOUT_REPORT_ENTRY_KEY;
import static org.junit.platform.reporting.open.xml.JUnitFactory.legacyReportingName;
import static org.junit.platform.reporting.open.xml.JUnitFactory.type;
import static org.junit.platform.reporting.open.xml.JUnitFactory.uniqueId;
import static org.opentest4j.reporting.events.core.CoreFactory.attachments;
import static org.opentest4j.reporting.events.core.CoreFactory.cpuCores;
import static org.opentest4j.reporting.events.core.CoreFactory.data;
import static org.opentest4j.reporting.events.core.CoreFactory.directorySource;
import static org.opentest4j.reporting.events.core.CoreFactory.file;
import static org.opentest4j.reporting.events.core.CoreFactory.fileSource;
import static org.opentest4j.reporting.events.core.CoreFactory.hostName;
import static org.opentest4j.reporting.events.core.CoreFactory.infrastructure;
import static org.opentest4j.reporting.events.core.CoreFactory.metadata;
import static org.opentest4j.reporting.events.core.CoreFactory.operatingSystem;
import static org.opentest4j.reporting.events.core.CoreFactory.output;
import static org.opentest4j.reporting.events.core.CoreFactory.reason;
import static org.opentest4j.reporting.events.core.CoreFactory.result;
import static org.opentest4j.reporting.events.core.CoreFactory.sources;
import static org.opentest4j.reporting.events.core.CoreFactory.tag;
import static org.opentest4j.reporting.events.core.CoreFactory.tags;
import static org.opentest4j.reporting.events.core.CoreFactory.uriSource;
import static org.opentest4j.reporting.events.core.CoreFactory.userName;
import static org.opentest4j.reporting.events.git.GitFactory.branch;
import static org.opentest4j.reporting.events.git.GitFactory.commit;
import static org.opentest4j.reporting.events.git.GitFactory.repository;
import static org.opentest4j.reporting.events.git.GitFactory.status;
import static org.opentest4j.reporting.events.java.JavaFactory.classSource;
import static org.opentest4j.reporting.events.java.JavaFactory.classpathResourceSource;
import static org.opentest4j.reporting.events.java.JavaFactory.fileEncoding;
import static org.opentest4j.reporting.events.java.JavaFactory.heapSize;
import static org.opentest4j.reporting.events.java.JavaFactory.javaVersion;
import static org.opentest4j.reporting.events.java.JavaFactory.methodSource;
import static org.opentest4j.reporting.events.java.JavaFactory.packageSource;
import static org.opentest4j.reporting.events.java.JavaFactory.throwable;
import static org.opentest4j.reporting.events.root.RootFactory.finished;
import static org.opentest4j.reporting.events.root.RootFactory.reported;
import static org.opentest4j.reporting.events.root.RootFactory.started;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UncheckedIOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.time.Instant;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;

import org.apiguardian.api.API;
import org.jspecify.annotations.Nullable;
import org.junit.platform.commons.JUnitException;
import org.junit.platform.commons.util.ExceptionUtils;
import org.junit.platform.commons.util.StringUtils;
import org.junit.platform.engine.ConfigurationParameters;
import org.junit.platform.engine.TestExecutionResult;
import org.junit.platform.engine.TestSource;
import org.junit.platform.engine.UniqueId;
import org.junit.platform.engine.reporting.FileEntry;
import org.junit.platform.engine.reporting.ReportEntry;
import org.junit.platform.engine.support.descriptor.ClassSource;
import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
import org.junit.platform.engine.support.descriptor.CompositeTestSource;
import org.junit.platform.engine.support.descriptor.DirectorySource;
import org.junit.platform.engine.support.descriptor.FileSource;
import org.junit.platform.engine.support.descriptor.MethodSource;
import org.junit.platform.engine.support.descriptor.PackageSource;
import org.junit.platform.engine.support.descriptor.UriSource;
import org.junit.platform.launcher.TestExecutionListener;
import org.junit.platform.launcher.TestIdentifier;
import org.junit.platform.launcher.TestPlan;
import org.opentest4j.reporting.events.api.DocumentWriter;
import org.opentest4j.reporting.events.api.NamespaceRegistry;
import org.opentest4j.reporting.events.core.Attachments;
import org.opentest4j.reporting.events.core.Infrastructure;
import org.opentest4j.reporting.events.core.Result;
import org.opentest4j.reporting.events.core.Sources;
import org.opentest4j.reporting.events.root.Events;
import org.opentest4j.reporting.schema.Namespace;

/**
 * Open Test Reporting events XML generating test execution listener.
 *
 * @since 1.9
 */
@API(status = EXPERIMENTAL, since = "1.9")
public class OpenTestReportGeneratingListener implements TestExecutionListener {

	static final String ENABLED_PROPERTY_NAME = "junit.platform.reporting.open.xml.enabled";

	private final AtomicInteger idCounter = new AtomicInteger();
	private final Map<UniqueId, String> inProgressIds = new ConcurrentHashMap<>();
	private DocumentWriter<Events> eventsFileWriter = DocumentWriter.noop();
	private final Path workingDir;

	private @Nullable Path outputDir;

	@SuppressWarnings("unused") // Used via ServiceLoader
	public OpenTestReportGeneratingListener() {
		this(Path.of(".").toAbsolutePath());
	}

	OpenTestReportGeneratingListener(Path workingDir) {
		this.workingDir = workingDir;
	}

	@Override
	public void testPlanExecutionStarted(TestPlan testPlan) {
		ConfigurationParameters config = testPlan.getConfigurationParameters();
		if (isEnabled(config)) {
			NamespaceRegistry namespaceRegistry = NamespaceRegistry.builder(Namespace.REPORTING_CORE) //
					.add("e", Namespace.REPORTING_EVENTS) //
					.add("git", Namespace.REPORTING_GIT) //
					.add("java", Namespace.REPORTING_JAVA) //
					.add("junit", JUnitFactory.NAMESPACE, "https://schemas.junit.org/open-test-reporting/junit-1.9.xsd") //
					.build();
			outputDir = testPlan.getOutputDirectoryProvider().getRootDirectory();
			Path eventsXml = outputDir.resolve("open-test-report.xml");
			try {
				eventsFileWriter = Events.createDocumentWriter(namespaceRegistry, eventsXml);
				reportInfrastructure();
			}
			catch (Exception e) {
				throw new JUnitException("Failed to initialize XML events file: " + eventsXml, e);
			}
		}
	}

	private Boolean isEnabled(ConfigurationParameters config) {
		return config.getBoolean(ENABLED_PROPERTY_NAME).orElse(false);
	}

	private void reportInfrastructure() {
		eventsFileWriter.append(infrastructure(), infrastructure -> {
			try {
				String hostName = InetAddress.getLocalHost().getHostName();
				infrastructure.append(hostName(hostName));
			}
			catch (UnknownHostException ignored) {
			}
			infrastructure //
					.append(userName(System.getProperty("user.name"))) //
					.append(operatingSystem(System.getProperty("os.name"))) //
					.append(cpuCores(Runtime.getRuntime().availableProcessors())) //
					.append(javaVersion(System.getProperty("java.version"))) //
					.append(fileEncoding(System.getProperty("file.encoding"))) //
					.append(heapSize(), heapSize -> heapSize.withMax(Runtime.getRuntime().maxMemory()));

			addGitInfo(infrastructure);
		});
	}

	private void addGitInfo(Infrastructure infrastructure) {
		boolean gitInstalled = exec("git", "--version").isPresent();
		if (gitInstalled) {
			exec("git", "config", "--get", "remote.origin.url") //
					.filter(StringUtils::isNotBlank) //
					.ifPresent(
						gitUrl -> infrastructure.append(repository(), repository -> repository.withOriginUrl(gitUrl)));
			exec("git", "rev-parse", "--abbrev-ref", "HEAD") //
					.filter(StringUtils::isNotBlank) //
					.ifPresent(branch -> infrastructure.append(branch(branch)));
			exec("git", "rev-parse", "--verify", "HEAD") //
					.filter(StringUtils::isNotBlank) //
					.ifPresent(gitCommitHash -> infrastructure.append(commit(gitCommitHash)));
			exec("git", "status", "--porcelain") //
					.ifPresent(statusOutput -> infrastructure.append(status(statusOutput),
						status -> status.withClean(statusOutput.isEmpty())));
		}
	}

	Optional<String> exec(String... args) {

		Process process = startProcess(args);

		try (Reader out = newBufferedReader(process.getInputStream());
				Reader err = newBufferedReader(process.getErrorStream())) {

			StringBuilder output = new StringBuilder();
			readAllChars(out, (chars, numChars) -> output.append(chars, 0, numChars));

			readAllChars(err, (__, ___) -> {
				// ignore
			});

			boolean terminated = process.waitFor(10, TimeUnit.SECONDS);
			return terminated && process.exitValue() == 0 ? Optional.of(trimAtEnd(output)) : Optional.empty();
		}
		catch (InterruptedException e) {
			throw ExceptionUtils.throwAsUncheckedException(e);
		}
		catch (IOException ignore) {
			return Optional.empty();
		}
		finally {
			process.destroyForcibly();
		}
	}

	private static BufferedReader newBufferedReader(InputStream stream) {
		return new BufferedReader(new InputStreamReader(stream, Charset.defaultCharset()));
	}

	private Process startProcess(String[] command) {
		Process process;
		try {
			process = new ProcessBuilder().directory(workingDir.toFile()).command(command).start();
		}
		catch (IOException e) {
			throw new UncheckedIOException("Failed to start process", e);
		}
		return process;
	}

	private static void readAllChars(Reader reader, BiConsumer<char[], Integer> consumer) throws IOException {
		char[] buffer = new char[1024];
		int numChars;
		while ((numChars = reader.read(buffer)) != -1) {
			consumer.accept(buffer, numChars);
		}
	}

	private static String trimAtEnd(StringBuilder value) {
		int endIndex = value.length();
		for (int i = value.length() - 1; i >= 0; i--) {
			if (Character.isWhitespace(value.charAt(i))) {
				endIndex--;
				break;
			}
		}
		return value.substring(0, endIndex);
	}

	@Override
	public void testPlanExecutionFinished(TestPlan testPlan) {
		try {
			eventsFileWriter.close();
		}
		catch (IOException e) {
			throw new UncheckedIOException("Failed to close XML events file", e);
		}
		finally {
			eventsFileWriter = DocumentWriter.noop();
		}
	}

	@Override
	public void executionSkipped(TestIdentifier testIdentifier, String reason) {
		String id = String.valueOf(idCounter.incrementAndGet());
		reportStarted(testIdentifier, id);
		eventsFileWriter.append(finished(id, Instant.now()), //
			finished -> finished.append(result(Result.Status.SKIPPED), result -> {
				if (isNotBlank(reason)) {
					result.append(reason(reason));
				}
			}));
	}

	@Override
	public void executionStarted(TestIdentifier testIdentifier) {
		String id = String.valueOf(idCounter.incrementAndGet());
		inProgressIds.put(testIdentifier.getUniqueIdObject(), id);
		reportStarted(testIdentifier, id);
	}

	private void reportStarted(TestIdentifier testIdentifier, String id) {
		eventsFileWriter.append(started(id, Instant.now(), testIdentifier.getDisplayName()), started -> {
			testIdentifier.getParentIdObject().ifPresent(parentId -> started.withParentId(inProgressIds.get(parentId)));
			started.append(metadata(), metadata -> {
				if (!testIdentifier.getTags().isEmpty()) {
					metadata.append(tags(), tags -> //
					testIdentifier.getTags().forEach(tag -> tags.append(tag(tag.getName()))));
				}
				metadata.append(uniqueId(testIdentifier.getUniqueId())) //
						.append(legacyReportingName(testIdentifier.getLegacyReportingName())) //
						.append(type(testIdentifier.getType()));
			});
			testIdentifier.getSource().ifPresent(
				source -> started.append(sources(), sources -> addTestSource(source, sources)));
		});
	}

	private void addTestSource(TestSource source, Sources sources) {
		if (source instanceof CompositeTestSource compositeSource) {
			compositeSource.getSources().forEach(it -> addTestSource(it, sources));
		}
		else if (source instanceof ClassSource classSource) {
			sources.append(classSource(classSource.getClassName()), //
				element -> classSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof MethodSource methodSource) {
			sources.append(methodSource(methodSource.getClassName(), methodSource.getMethodName()), element -> {
				String methodParameterTypes = methodSource.getMethodParameterTypes();
				if (methodParameterTypes != null) {
					element.withMethodParameterTypes(methodParameterTypes);
				}
			});
		}
		else if (source instanceof ClasspathResourceSource classpathResourceSource) {
			sources.append(classpathResourceSource(classpathResourceSource.getClasspathResourceName()), //
				element -> classpathResourceSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof PackageSource packageSource) {
			sources.append(packageSource(packageSource.getPackageName()));
		}
		else if (source instanceof FileSource fileSource) {
			sources.append(fileSource(fileSource.getFile()), //
				element -> fileSource.getPosition().ifPresent(
					filePosition -> element.addFilePosition(filePosition.getLine(), filePosition.getColumn())));
		}
		else if (source instanceof DirectorySource directorySource) {
			sources.append(directorySource(directorySource.getFile()));
		}
		else if (source instanceof UriSource uriSource) {
			sources.append(uriSource(uriSource.getUri()));
		}
	}

	@Override
	public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
		String id = inProgressIds.get(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(reported(id, Instant.now()), //
			reported -> reported.append(attachments(), //
				attachments -> {
					Map<String, String> keyValuePairs = entry.getKeyValuePairs();
					if (keyValuePairs.containsKey(STDOUT_REPORT_ENTRY_KEY)
							|| keyValuePairs.containsKey(STDERR_REPORT_ENTRY_KEY)) {
						attachOutput(attachments, entry.getTimestamp(), keyValuePairs.get(STDOUT_REPORT_ENTRY_KEY),
							"stdout");
						attachOutput(attachments, entry.getTimestamp(), keyValuePairs.get(STDERR_REPORT_ENTRY_KEY),
							"stderr");
					}
					else {
						attachments.append(data(entry.getTimestamp()), //
							data -> keyValuePairs.forEach(data::addEntry));
					}
				}));
	}

	private static void attachOutput(Attachments attachments, LocalDateTime timestamp, @Nullable String content,
			String source) {
		if (content != null) {
			attachments.append(output(timestamp), output -> output.withSource(source).withContent(content));
		}
	}

	@Override
	public void fileEntryPublished(TestIdentifier testIdentifier, FileEntry entry) {
		String id = inProgressIds.get(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(reported(id, Instant.now()), //
			reported -> reported.append(attachments(), attachments -> attachments.append(file(entry.getTimestamp()), //
				file -> {
					file.withPath(requireNonNull(outputDir).relativize(entry.getPath()).toString());
					entry.getMediaType().ifPresent(file::withMediaType);
				})));
	}

	@Override
	public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
		String id = inProgressIds.remove(testIdentifier.getUniqueIdObject());
		eventsFileWriter.append(finished(id, Instant.now()), //
			finished -> finished.append(result(convertStatus(testExecutionResult.getStatus())), //
				result -> testExecutionResult.getThrowable() //
						.ifPresent(throwable -> result.append(throwable(throwable)))));
	}

	private Result.Status convertStatus(TestExecutionResult.Status status) {
		return switch (status) {
			case FAILED -> Result.Status.FAILED;
			case SUCCESSFUL -> Result.Status.SUCCESSFUL;
			case ABORTED -> Result.Status.ABORTED;
		};
	}

}
